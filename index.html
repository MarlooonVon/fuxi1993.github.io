<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>My Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="My Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="My Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="My Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://i3.tietuku.com/c9c79e4be8360f8e.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Fu Xi</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/fuxi1993" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/2495420042/profile?topnav=1&wvr=6" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/hill-fu" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/Spark/" style="font-size: 13.33px;">Spark</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/toast/" style="font-size: 10px;">toast</a> <a href="/tags/读书笔记/" style="font-size: 20px;">读书笔记</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://tsien.github.io/">Tsien的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://gsclife.info/">gsclife的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">Duty First</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Fu Xi</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://i3.tietuku.com/c9c79e4be8360f8e.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Fu Xi</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/fuxi1993" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/2495420042/profile?topnav=1&wvr=6" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/hill-fu" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Spark-SQL对多数据源的支持" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/03/Spark-SQL对多数据源的支持/" class="article-date">
  	<time datetime="2016-01-03T11:08:17.000Z" itemprop="datePublished">2016-01-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/03/Spark-SQL对多数据源的支持/">Spark SQL对多数据源的支持</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_什么是Spark_SQL?">1. 什么是Spark SQL?</h2><p>Spark SQL是一个针对结构化数据的Spark框架，它提供了一个叫DataFrames的编程抽象，而且还可以扮演分布式SQL查询引擎的角色。</p>
<h3 id="1-1_Spark_SQL提供的数据抽象:DataFrame">1.1 Spark SQL提供的数据抽象:DataFrame</h3><p>一个DataFrame是一个列式数据构成的数据集合。它概念上等同于关系数据库中的一张表或者Python/R语言中的框架，但是在底层有更多的优化。DataFrame可以通过广泛的数据源来构建，例如：结构化的数据文件、Hive中的表、外部的数据库，或者已经存在的RDD。</p>
<blockquote>
<p>关于Spark SQL更多的介绍，可见<a href="http://spark.apache.org/docs/latest/sql-programming-guide.html#creating-dataframes" target="_blank" rel="external">Spark SQL and DataFrame Guide</a></p>
</blockquote>
<h2 id="2-_支持JSON数据类型">2. 支持JSON数据类型</h2><p>以下关于Spark SQL对JSON文件的处理过程同样适用与其他各种类型的外部数据源，DataFrame数据结构提供了统一的数据抽象。</p>
<h3 id="2-1_开始：SQLContext">2.1 开始：SQLContext</h3><p>Spark SQL的入口是SQLContext类（或者是它的子类）。为了创建SQLContext，只需要SparkContext。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sc</span>:</span> <span class="type">SparkContext</span> <span class="comment">// An existing SparkContext.</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sqlContext</span> =</span> <span class="keyword">new</span> org.apache.spark.sql.<span class="type">SQLContext</span>(sc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is used to implicitly convert an RDD to a DataFrame.</span></span><br><span class="line"><span class="keyword">import</span> sqlContext.implicits._</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2_创建DataFrame">2.2 创建DataFrame</h3><p>利用SQLContext，应用可以从一个已存在的RDD（需要知道Schema）、Hive Table、各种外部数据源来创建DataFrame。<br>下面是基于一个JSON文件的内容创建一个DataFrame：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sc</span>:</span> <span class="type">SparkContext</span> <span class="comment">// An existing SparkContext.</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sqlContext</span> =</span> <span class="keyword">new</span> org.apache.spark.sql.<span class="type">SQLContext</span>(sc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">df</span> =</span> sqlContext.read.json(<span class="string">"examples/src/main/resources/people.json"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Displays the content of the DataFrame to stdout</span></span><br><span class="line">df.show()</span><br></pre></td></tr></table></figure></p>
<p>###2.3 DataFrame的操作<br>DataFrame以Scala, Java, Python语言为结构化的数据操作提供了域限定性语言。<br>下面展示了使用DataFrame进行一些基本的结构化数据操作：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sc</span>:</span> <span class="type">SparkContext</span> <span class="comment">// An existing SparkContext.</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sqlContext</span> =</span> <span class="keyword">new</span> org.apache.spark.sql.<span class="type">SQLContext</span>(sc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the DataFrame</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">df</span> =</span> sqlContext.read.json(<span class="string">"examples/src/main/resources/people.json"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show the content of the DataFrame</span></span><br><span class="line">df.show()</span><br><span class="line"><span class="comment">// age  name</span></span><br><span class="line"><span class="comment">// null Michael</span></span><br><span class="line"><span class="comment">// 30   Andy</span></span><br><span class="line"><span class="comment">// 19   Justin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the schema in a tree format</span></span><br><span class="line">df.printSchema()</span><br><span class="line"><span class="comment">// root</span></span><br><span class="line"><span class="comment">// |-- age: long (nullable = true)</span></span><br><span class="line"><span class="comment">// |-- name: string (nullable = true)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Select only the "name" column</span></span><br><span class="line">df.select(<span class="string">"name"</span>).show()</span><br><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="comment">// Michael</span></span><br><span class="line"><span class="comment">// Andy</span></span><br><span class="line"><span class="comment">// Justin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Select everybody, but increment the age by 1</span></span><br><span class="line">df.select(df(<span class="string">"name"</span>), df(<span class="string">"age"</span>) + <span class="number">1</span>).show()</span><br><span class="line"><span class="comment">// name    (age + 1)</span></span><br><span class="line"><span class="comment">// Michael null</span></span><br><span class="line"><span class="comment">// Andy    31</span></span><br><span class="line"><span class="comment">// Justin  20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Select people older than 21</span></span><br><span class="line">df.filter(df(<span class="string">"age"</span>) &gt; <span class="number">21</span>).show()</span><br><span class="line"><span class="comment">// age name</span></span><br><span class="line"><span class="comment">// 30  Andy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Count people by age</span></span><br><span class="line">df.groupBy(<span class="string">"age"</span>).count().show()</span><br><span class="line"><span class="comment">// age  count</span></span><br><span class="line"><span class="comment">// null 1</span></span><br><span class="line"><span class="comment">// 19   1</span></span><br><span class="line"><span class="comment">// 30   1</span></span><br></pre></td></tr></table></figure></p>
<p>关于DataFrame的全部的操作列表，可见<a href="http://spark.apache.org/docs/latest/api/java/org/apache/spark/sql/DataFrame.html" target="_blank" rel="external">the API Documentation</a>。<br>除了上面这些简单的列操作已经表达式操作，DataFrame还有一个丰富的库来支持字符串操作，数值运算等。完整的列表可见<a href="http://spark.apache.org/docs/latest/api/java/org/apache/spark/sql/functions.html" target="_blank" rel="external">DataFrame Function Reference</a>。</p>
<h3 id="2-4_运行SQL查询语句">2.4 运行SQL查询语句</h3><p>SQLContext类中的sql函数可以使应用程序化的运行SQL 查询语句，并且以DataFrame的形式返回。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sqlContext</span> =</span> ...  <span class="comment">// An existing SQLContext</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">df</span> =</span> sqlContext.sql(<span class="string">"SELECT * FROM table"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="3-_解释RDD">3. 解释RDD</h2><p>Spark SQL支持两种不同的方法将现有的RDD转化为DataFrames。第一种方法是使用反射来导出一个RDD的schema。写spark的应用程序时，在已知数据的schema的时候，反射的方法可以帮助写出更简介的代码。<br>第二种方法，通过一个编程接口（这个编程接口可以帮助你构建一个schema并且应用到一个已经存在的RDD上）。</p>
<h3 id="3-1_利用反射来导出Schema">3.1 利用反射来导出Schema</h3><p>Spark SQL 的scala接口支持将一个包含类类型(case class)的RDD转换成DataFrame的接口。类类型(case class)定义了表的schema。通过反射机制来读取类类型的参数，其将成为列名(column)，类类型(case class)也支持嵌套以及复杂的数据类型，像Sequence 和 Array。这种RDD可以被隐式地转换成DataFrame并转换成表，然后就可以执行SQL操作。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sc is an existing SparkContext.</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sqlContext</span> =</span> <span class="keyword">new</span> org.apache.spark.sql.<span class="type">SQLContext</span>(sc)</span><br><span class="line"><span class="comment">// this is used to implicitly convert an RDD to a DataFrame.</span></span><br><span class="line"><span class="keyword">import</span> sqlContext.implicits._</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the schema using a case class.</span></span><br><span class="line"><span class="comment">// Note: Case classes in Scala 2.10 can support only up to 22 fields. To work around this limit,</span></span><br><span class="line"><span class="comment">// you can use custom classes that implement the Product interface.</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(</span>name: <span class="type">String</span>, age: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an RDD of Person objects and register it as a table.</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">people</span> =</span> sc.textFile(<span class="string">"examples/src/main/resources/people.txt"</span>).map(_.split(<span class="string">","</span>)).map(p =&gt; <span class="type">Person</span>(p(<span class="number">0</span>), p(<span class="number">1</span>).trim.toInt)).toDF()</span><br><span class="line">people.registerTempTable(<span class="string">"people"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQL statements can be run by using the sql methods provided by sqlContext.</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">teenagers</span> =</span> sqlContext.sql(<span class="string">"SELECT name, age FROM people WHERE age &gt;= 13 AND age &lt;= 19"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The results of SQL queries are DataFrames and support all the normal RDD operations.</span></span><br><span class="line"><span class="comment">// The columns of a row in the result can be accessed by field index:</span></span><br><span class="line">teenagers.map(t =&gt; <span class="string">"Name: "</span> + t(<span class="number">0</span>)).collect().foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or by field name:</span></span><br><span class="line">teenagers.map(t =&gt; <span class="string">"Name: "</span> + t.getAs[<span class="type">String</span>](<span class="string">"name"</span>)).collect().foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="comment">// row.getValuesMap[T] retrieves multiple columns at once into a Map[String, T]</span></span><br><span class="line">teenagers.map(_.getValuesMap[<span class="type">Any</span>](<span class="type">List</span>(<span class="string">"name"</span>, <span class="string">"age"</span>))).collect().foreach(println)</span><br><span class="line"><span class="comment">// Map("name" -&gt; "Justin", "age" -&gt; 19)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-2_利用编程接口来得出Schema">3.2 利用编程接口来得出Schema</h3><p>当一个case class类没有事先定义的时候（比如说，一个记录的结构被编码进了一个字符串中，或者是一个文本集，它针对不同的用户可能解析不同的field），则一个DataFrame可以通过下面三步构造成功：</p>
<ol>
<li>从一个存在RDD中构造行RDD（RDD of Rows）；</li>
<li>从步骤1中每行对应的结构类型中构造Schema；</li>
<li>通过CreateDataFrame方法将每行的Schema(schema of rows)应用到行RDD中；</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sc is an existing SparkContext.</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sqlContext</span> =</span> <span class="keyword">new</span> org.apache.spark.sql.<span class="type">SQLContext</span>(sc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an RDD</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">people</span> =</span> sc.textFile(<span class="string">"examples/src/main/resources/people.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The schema is encoded in a string</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">schemaString</span> =</span> <span class="string">"name age"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Import Row.</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Import Spark SQL data types</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types.&#123;<span class="type">StructType</span>,<span class="type">StructField</span>,<span class="type">StringType</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the schema based on the string of schema</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">schema</span> =</span></span><br><span class="line">  <span class="type">StructType</span>(</span><br><span class="line">    schemaString.split(<span class="string">" "</span>).map(fieldName =&gt; <span class="type">StructField</span>(fieldName, <span class="type">StringType</span>, <span class="literal">true</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert records of the RDD (people) to Rows.</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">rowRDD</span> =</span> people.map(_.split(<span class="string">","</span>)).map(p =&gt; <span class="type">Row</span>(p(<span class="number">0</span>), p(<span class="number">1</span>).trim))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the schema to the RDD.</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">peopleDataFrame</span> =</span> sqlContext.createDataFrame(rowRDD, schema)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the DataFrames as a table.</span></span><br><span class="line">peopleDataFrame.registerTempTable(<span class="string">"people"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQL statements can be run by using the sql methods provided by sqlContext.</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">results</span> =</span> sqlContext.sql(<span class="string">"SELECT name FROM people"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The results of SQL queries are DataFrames and support all the normal RDD operations.</span></span><br><span class="line"><span class="comment">// The columns of a row in the result can be accessed by field index or by field name.</span></span><br><span class="line">results.map(t =&gt; <span class="string">"Name: "</span> + t(<span class="number">0</span>)).collect().foreach(println)</span><br></pre></td></tr></table></figure>
<h2 id="4-_支持MySQL等关系型数据库">4. 支持MySQL等关系型数据库</h2><h2 id="5-_支持MangoDB等非惯性数据库">5. 支持MangoDB等非惯性数据库</h2><h2 id="6-_支持HBase">6. 支持HBase</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/">SQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spark/">Spark</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-解忧杂货店" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/10/解忧杂货店/" class="article-date">
  	<time datetime="2015-10-10T12:25:04.000Z" itemprop="datePublished">2015-10-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/10/解忧杂货店/">《解忧杂货店》</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>如果把找我咨询的人比喻成迷途的羔羊，通常他们手上都有地图，却没有去看，或是不知道自己目前的位置。但是我相信你不属于这两种情况。你的地图是一张白纸，所以即使想决定目的地，也不知道路在哪里。地图是一张白纸，这当然很伤脑筋。任何人都会不知所措。可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己。对你来说，一切都是自由的，在你面前是无限的可能。这可是很棒的事情啊。我衷心祈祷你可以相信自己，无悔地燃烧自己的人生。</p>
</blockquote>
<p>一间小小的杂货店，将几个处在人生岔路口的年轻人纠缠在一起。三个自称为“社会的渣滓”的无业小偷；因为男友身患癌症，在参加奥运会集训和陪伴男友的选择中迷茫的女运动员；在音乐梦想和继承祖传鱼店之间徘徊的音乐人；在当陪酒小姐赚快钱和独自开店创业的矛盾中挣扎的“迷途的小狗”…他们的迷茫好似互不相关，毫无关联，但是因为“解忧杂货店”的信箱和孤儿院“丸光园”被紧紧地联系在一起，最终，他们每个人都找到了补住内心漏洞的方法，找到了各自的人生方向，也深深地感受到了这个世界的善意和温暖。翔太、敦也、幸平是三个自称为“社会的渣滓”的社会青年，他们在进行一次绑架后不经意间躲到了浪矢老爷爷家杂货店里，却无意间收到了来自过去的咨询信，因为这件奇妙的房子，将他们和过去的几个人联系在一起，努力训练的击剑选手月兔因为他们的信最终坚持了自己的决定，即便他们好像不是因为他们；在隔着门听完那曲著名的《重生》后恍然大悟，将“丸光园”失火、慰问演出的歌手、以及后来成为著名歌手的孤儿小芹、、、这一切都联系在一起，因此鼓励那位徘徊的鱼店音乐人要坚持下去，说出“你对音乐的执着追求，绝不是白白付出”的话；指导“迷途的小狗”学习房地产、证券交易等方面的知识并告诉她最好的进军市场的时间；却发现自己绑架的那个女人就是曾经知道的“迷途的小狗”，因为“迷途的小狗”的感谢信而迷途知返、、、每个人的故事都像河面的独立涟漪一样，不可思议的交汇在一起，形成奇妙而和谐的共振。<br>    下面这段话引用自豆瓣，同时也代表了我读这本书的感受：</p>
<blockquote>
<p>“《解忧杂货店》缜密的故事架构与精妙的情节设计，让人不得不叹服：“才华”这东西，真是与生俱来啊﹗更重要的是，东野圭吾在洞悉世情与人心之余，愿以善意回应，让人明白在这破洞不断的世界里，仍有人竭尽所能在用心填补，知道每个人活在这世上都不容易，都有各自的难题，都有难以启齿而感觉被世界孤立的那一刻，也明白人们需要的未必是如何解决的答案，而是那一刻有人愿意认真倾听，且愿意与孤绝的自己同在。这就是《解忧杂货店》的精神，也是我心中书写价值的所在。 ”</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Apache-Spark-利用Intellij-IDEA开发Spark程序" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/04/Apache-Spark-利用Intellij-IDEA开发Spark程序/" class="article-date">
  	<time datetime="2015-09-04T08:29:50.000Z" itemprop="datePublished">2015-09-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/04/Apache-Spark-利用Intellij-IDEA开发Spark程序/">Apache-Spark:利用Intellij IDEA开发Spark程序</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_准备工作">1. 准备工作</h2><ol>
<li>安装JDK7</li>
<li>安装Scala 2.10.x（因为实验室的spark集群是1.1.1版本的，它指定需要Scala 2.10.x版本）</li>
<li>Intellij IDEA Community Edition 14.1.4, 在安装的时候可以安装Scala插件，后面就不需要安装啦。</li>
</ol>
<h2 id="2-_WordCount例子">2. WordCount例子</h2><h3 id="2-1_新建Maven工程">2.1 新建Maven工程</h3><p>在intellij IDEA中创建Maven project, “File”-&gt;”New”-&gt;”Project”-&gt;”Maven”，填入相关信息，如下：<br><img src="/images/Spark/1.png" alt="picture"></p>
<h2 id="2-2_编写pom-xml文件">2.2 编写pom.xml文件</h2><p>在pom.xml文件加入依赖和插件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spark-core_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-3_导入相关的包">2.3 导入相关的包</h2><h3 id="2-3-1_导入spark的JAR包">2.3.1 导入spark的JAR包</h3><p>选择“File”–&gt; “project structure” –&gt; “Libraries”，选择“+”，将spark-hadoop 对应的包导入，比如导入spark-examples-1.1.1-hadoop2.3.0.jar（它在Spark的安装目录的lib文件夹下）。<br><img src="/images/Spark/2.png" alt="picture"></p>
<h3 id="2-3-2_导入scala库">2.3.2 导入scala库</h3><p>选择“File”–&gt; “project structure” –&gt; “Modules”，选择“+”，会自动出现Scala的库选项，添加,“Apply”-&gt;“OK”。<br><img src="/images/Spark/4.png" alt="picture"></p>
<h3 id="2-4_新建WordCount_Java类">2.4 新建WordCount Java类</h3><p>在src/main/java下新建Java类，取名“WordCount”，添加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkConf;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaPairRDD;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaRDD;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaSparkContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.Function2;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.PairFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern SPACE = Pattern.compile(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//System.setProperty("hadoop.home.dir", "c:\\winutil\\");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Usage: JavaWordCount &lt;file&gt;"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        SparkConf sparkConf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"WordCount"</span>);</span><br><span class="line">        sparkConf.setMaster(<span class="string">"local"</span>);</span><br><span class="line">        JavaSparkContext ctx = <span class="keyword">new</span> JavaSparkContext(sparkConf);</span><br><span class="line">        JavaRDD&lt;String&gt; lines = ctx.textFile(args[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        JavaRDD&lt;String&gt; words = lines.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Arrays.asList(SPACE.split(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        JavaPairRDD&lt;String, Integer&gt; ones = words.mapToPair(<span class="keyword">new</span> PairFunction&lt;String, String, Integer&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Tuple2&lt;String, Integer&gt; call(String s) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(s, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        JavaPairRDD&lt;String, Integer&gt; counts = ones.reduceByKey(<span class="keyword">new</span> Function2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer i1, Integer i2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i1 + i2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;Tuple2&lt;String, Integer&gt;&gt; output = counts.collect();</span><br><span class="line">        <span class="keyword">for</span> (Tuple2&lt;?,?&gt; tuple : output) &#123;</span><br><span class="line">            System.out.println(tuple._1() + <span class="string">": "</span> + tuple._2());</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.stop();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis() - begin;</span><br><span class="line">        System.out.println(<span class="string">"wasting time:"</span>+end+<span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-5_配置运行">2.5 配置运行</h3><p>点击“Run”-&gt;“Run”设置相关参数，如下：<br><img src="/images/Spark/3.png" alt="picture"><br>“Apply”-&gt;“Run”。<br>运行结果如下图所示：<br><img src="/images/Spark/5.png" alt="picture"></p>
<h2 id="3-_注意：">3. 注意：</h2><ol>
<li>在Windows下运行需要Spark需要hadoop的插件包：<a href="http://jingyan.baidu.com/article/d3b74d64cc2a0c1f77e609d2.html" target="_blank" rel="external">help</a></li>
<li>如果出现“ A master URL must be set in your configuration”错误：参见<a href="http://www.ithao123.cn/content-514918.html" target="_blank" rel="external">help1</a></li>
</ol>
<h2 id="4-_参考资料">4. 参考资料</h2><ol>
<li><a href="http://spark.apache.org/" target="_blank" rel="external">Spark</a>;</li>
<li><a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="external">intellij IDEA</a></li>
<li><a href="http://hadoop.apache.org/" target="_blank" rel="external">Hadoop</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spark/">Spark</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-暑期总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/28/暑期总结/" class="article-date">
  	<time datetime="2015-08-28T09:30:26.000Z" itemprop="datePublished">2015-08-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/28/暑期总结/">暑期总结（2015）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本科毕业典礼一完事，就早早地被学校赶回家了，非常感谢胖子和知雨兄最后的送行，感觉在大学四年能有几个志同道合的小伙伴还是一件蛮幸运的事 o(∩_∩)o 。然后就好好的在家里躺尸了几天，吃了几天妈妈吃的饭菜，就开始整理大学四年的一些记忆了，整理了几天，发现自己果然是一个拍照狂魔啊，好的差的拍了几万张，一张一张的整理了两三天，终于挑好了一些自己觉得满意的几百张照片。整理了将近两个星期，终于把这些杂七杂八的东西整理完了。接下来就要好好考虑该干嘛了，正好又买了Kindle,我就看了一些自己感兴趣的书籍，现一一列出：</p>
<h2 id="1-演讲之禅">1.<a href="http://book.douban.com/subject/4760725/" target="_blank" rel="external">演讲之禅</a></h2><p>这是一本介绍关于演讲技巧的书籍，作者是一位技术演讲家，常年在各大互联网公司之间进行技术性的演讲。作者根据他多年的演讲经历总结了一些十分实用的演讲技巧。看完后，我觉得这是一本十分使用的书籍，书中的很多技巧无论对于小型演讲还是大型演讲都是十分有效的。</p>
<h2 id="2-平凡的世界">2.<a href="http://book.douban.com/subject/6835758/" target="_blank" rel="external">平凡的世界</a></h2><p>无需多言，经典中的经典，作者平实的语言深刻形象地刻画了几个人物形象，尤为佩服孙少平和孙少安，他们都是铁骨铮铮的汉子！</p>
<h2 id="3-明朝那些事儿">3.<a href="http://book.douban.com/subject/7163250/" target="_blank" rel="external">明朝那些事儿</a></h2><p>一本通俗有趣的历史科普书，本来以前也完整地看过一偏，但是意犹未尽，于是又看了一偏，记得看得第一遍的时候，只觉得里面的历史故事都蛮有趣的，但是这次再读的时候，我感受到了更多的东西，感受到名族大义与一己私利，忠诚与背叛，理性和感性，永垂不朽与遗臭万年，阿谀奉承与刚正不阿…。</p>
<h2 id="4-深入理解Java虚拟机">4.<a href="http://book.douban.com/subject/6522893/" target="_blank" rel="external">深入理解Java虚拟机</a></h2><p>这是我读过的为数不多的国人写过的好的技术书籍之一。书中对于JVM的内存管理系统，执行子系统，程序编译和优化等内容都有很详细的介绍。我觉得对于想从事Java编程的人都应该读一下这本书。值得再看一遍。</p>
<h2 id="5-Effective_Java">5.<a href="http://book.douban.com/subject/3360807/" target="_blank" rel="external">Effective Java</a></h2><p>本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。但是以现在我的编程经验对于里面一些内容还不能理解，看来还要加强学习实践。这是一本值得多看几遍的书籍。</p>
<h2 id="6-美国纽约摄影学院摄影教材">6.<a href="http://book.douban.com/subject/1007928/" target="_blank" rel="external">美国纽约摄影学院摄影教材</a></h2><p>觉得自己既然这么喜欢拍照，应该加强一下自己的拍照技巧，然后就在网上找到这本书，不得不说，对于喜欢摄影的人来说，这真的是一本非常合适的入门书籍，但是我只看了60%，因为暂时还没有买单反的计划 orz,就没有再看下去的动力了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-deep-into-JVM-6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/06/deep-into-JVM-6/" class="article-date">
  	<time datetime="2015-08-06T13:09:21.000Z" itemprop="datePublished">2015-08-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/06/deep-into-JVM-6/">深入理解JVM(6)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是我写的关于《深入理解Java虚拟机：JVM高级特性与最佳实战（第2版）》的读书笔记。</p>
<h1 id="早期（编译期）优化">早期（编译期）优化</h1><h2 id="概述">概述</h2><ul>
<li>前端编译器：Sun的Javac、 Eclipse JDT中的增量编译器</li>
<li>JIT编译器： HotSpot VM的C1、C2编译器</li>
<li>AOT编译器： GNU Compiler for Java<br>虚拟机设计团队把对性能的优化集中到后端的即时编译器中，这样能够保证让那些不是由Javac产生的Class文件也能同样能享受到编译器优化所带来的好处。</li>
</ul>
<h2 id="Javac编译器">Javac编译器</h2><ol>
<li>解析与填充符号表的过程</li>
<li>插入式注解处理器的注解处理过程</li>
<li>分析与字节码生成过程</li>
</ol>
<h2 id="Java语法糖的味道">Java语法糖的味道</h2><h3 id="Java泛型">Java泛型</h3><p>Java语言中的泛型，在编译后的字节码文件中，就已经被替换为原来的原生类型（Raw Type）了，并且在相应的地方插入了强制转型代码，因此对于运行期Java来说，ArrayList<int>与ArrayList<string>就是同一个类。所以说Java语言中的泛型实现成为类型擦除，基于这种方法实现的泛型被称为伪泛型。<br>将如下代码编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Map&lt;String, String&gt; map = <span class="keyword">new</span> Map&lt;String, String&gt;();</span><br><span class="line">	map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">	map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没"</span>);</span><br><span class="line">	system.out.println(map.get(<span class="string">"hello"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string></int></p>
<p>将这段代码编译成Class文件，然后在反编译，将会发现泛型都不见了，程序又变成Java泛型出现之前的写法，泛型类型都变回了原生类型，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Strings[] args)</span> </span>&#123;</span><br><span class="line">	Map map = <span class="keyword">new</span> map();</span><br><span class="line">	map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">	map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没"</span>);</span><br><span class="line">	system.out.println(map.get(<span class="string">"hello"</span>));	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>通过泛型擦除法来实现泛型丧失了泛型思想一些应有的优雅</strong></p>
</blockquote>
<p>例如一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">	    System.out.println(<span class="string">"Invoke method 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Invoke method 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码不能被正常编译，因为两个参数在编译之后都被擦除了，变成了原生类型List<e>, 擦除动作导致这两个方法的特征签名变得一模一样。</e></p>
<h3 id="自动装箱、拆箱与遍历循环">自动装箱、拆箱与遍历循环</h3><ul>
<li>遍历循环需要被遍历的类实现Iterable接口。</li>
</ul>
<h1 id="晚期（运行时）优化">晚期（运行时）优化</h1><h2 id="概述-1">概述</h2><p>在现在JVM虚拟机中，基本都是解释器和即时编译器共存工作的。</p>
<h2 id="HotSpot虚拟机里面的即时编译器">HotSpot虚拟机里面的即时编译器</h2><p>会被即时编译器编译的“热点代码”有两类：</p>
<ul>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ul>
<blockquote>
<p>对于后面一种情况，尽管编译动作时有循环体触发的，但编译器依然会以整个方法作为编译对象。这种编译方法因为编译发生在方法执行过程之中，因此被很形象的称为栈上替换（On Stack Replacement, OSR）。</p>
</blockquote>
<p>在HotSpot虚拟机中使用基于计数器的热点探测方法，它为每个方法准备了两个计数器：方法调用计数器和回边计数器。</p>
<p>下图显示了方法调用计数器触发即时编译：<br><img src="/images/JVM/JVM14.jpg" alt="picture"><br>下图显示了回边计数器触发即时编译：<br><img src="/images/JVM/JVM15.jpg" alt="picture"></p>
<h2 id="Java_vs_C/C++">Java vs C/C++</h2><p>缺点：</p>
<ol>
<li>Java 即时编译器运行占用的是用户程序的时间</li>
<li>Java语言是动态的类型安全语言，所以虚拟机虚拟机需要频繁的进行各种检查，耗费时间。</li>
<li>Java中的多态选择远多余C++语言。</li>
<li>Java的内存回收压力要远大于C/C++语言。<br>优点：</li>
<li>开发的效率会更高</li>
<li>Java的即时编译器能进行动态优化，而C++不行。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-deep-into-JVM-4-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/04/deep-into-JVM-4-1/" class="article-date">
  	<time datetime="2015-08-04T13:43:42.000Z" itemprop="datePublished">2015-08-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/04/deep-into-JVM-4-1/">深入理解JVM(5)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是我写的关于《深入理解Java虚拟机：JVM高级特性与最佳实战（第2版）》的读书笔记。</p>
<h1 id="虚拟机类加载机制">虚拟机类加载机制</h1><p>与C++语言在编译时需要进行链接工作不同，Java语言里，类的加载和链接都是在运行时完成的，Java语言的动态扩展的特性便是依赖运行期动态加载和动态连接这个特点实现的。</p>
<h2 id="类加载的时机">类加载的时机</h2><p>类从加载到虚拟机内存中开始，到卸载出内存为止，共经历了七个阶段。<br><img src="/images/JVM/JVM10.jpg" alt="类的生命周期"><br>如图，加载、验证、准备、初始化和卸载这五个过程是确定的，解析过程则不一定：它在某些情况下可以在初始化之后开始，这样是为了支持Java语言的运行时绑定。<br>jvm规定了下面四种情况需要立即对类进行“初始化”（而加载，验证，准备工作自然要在此之前）：</p>
<ol>
<li>遇到new、getstatic、putstatic、invokestatic这四条指令时，如果类没有进行初始化(被final修饰、已在编译期把结果放入常量池的静态字段除外)，需要先触发初始化。</li>
<li>遇到java.lang.reflect包方法对类进行发射调用时。</li>
<li>当一个类进行初始化时，如果发现其父类还未进行初始化时。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。</li>
</ol>
<p>以上四类场景成为类的主动引用，除此之外所有引用类的方式，都不会触发初始化，成为被动引用。</p>
<h2 id="类加载的过程">类加载的过程</h2><h3 id="1-加载">1.加载</h3><p>在加载阶段，虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</li>
</ol>
<h3 id="2-验证">2.验证</h3><p>验证阶段虚拟机类加载机制里面的一项很重要的步骤。主要包括四个阶段。</p>
<ol>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证：确保解析动作的职场执行。</li>
</ol>
<h3 id="3-准备">3.准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。</p>
<blockquote>
<p>这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</blockquote>
<h3 id="4-解析">4.解析</h3><p>解析阶段是虚拟机将常量池内符号引用替换为直接引用的过程。<br>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。</p>
<ol>
<li>类或接口的解析<br>假设当前代码所处的类为D,如果要把一个从未解析过的符号引用解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：<ol>
<li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。</li>
<li>如果C是一个数组类型，并且数组类型为对象，那就按照点1的规则进行。<br>3.略</li>
</ol>
</li>
<li>字段解析</li>
<li>类方法解析</li>
<li>接口方法解析</li>
</ol>
<h3 id="5-初始化">5.初始化</h3><p>类初始化阶段是类加载过程的最后一步。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p>
<ul>
<li><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{} 块)中的语句合并产生的。</clinit></li>
<li><clinit>()方法与类的构造函数(或者说实例构造器<init>()方法)不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。</clinit></clinit></init></clinit></li>
<li>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></li>
<li><clinit>()方法不是必须的。</clinit></li>
</ul>
<h2 id="类加载器">类加载器</h2><p>定义：虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。</p>
<h3 id="类与类加载器">类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。</p>
<h3 id="双亲委派模型"><strong>双亲委派模型</strong></h3><p>从Java开发人员的角度来看，类加载器可以分为三类。<br><img src="/images/JVM/JVM11.PNG" alt="类加载器"></p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）:Bootstrap类加载器通常是由本地码实现的，因为它在JVM被装载时就被实例化了。Bootstrap类加载器负责加载基础的Java API,像rt.jar。它只加载在启动路径上的类。</li>
<li>扩展类加载器（Extension ClassLoader）:Extension 类加载器加载标准的Java扩展API，像安全扩展功能。</li>
<li>应用程序类（系统类）加载器（System class ClassLoader）：负责加载用户类路径上所指定的类库。</li>
</ul>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这个类加载器之间的父子关系一般不会以继承的关系实现，而是使用组合关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器受到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去实现，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有扎到所需要的类）时，子加载器才会尝试自己去加载。<br>双亲委派模型的好处是：保证了Java程序的稳定运行。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-deep-into-JVM-4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/03/deep-into-JVM-4/" class="article-date">
  	<time datetime="2015-08-03T12:21:51.000Z" itemprop="datePublished">2015-08-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/03/deep-into-JVM-4/">深入理解JVM(4)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是我写的关于《深入理解Java虚拟机：JVM高级特性与最佳实战（第2版）》的读书笔记。</p>
<h1 id="类文件结构">类文件结构</h1><p>因为虚拟机可以载入以及运行同一平台无关的字节码，从而实现了程序的“一次编写，出处运行”。</p>
<h2 id="Class类文件的结构">Class类文件的结构</h2><p>一个编译后的类文件结构如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4			magic;</span><br><span class="line">    u2			minor_version;</span><br><span class="line">    u2			major_version;</span><br><span class="line">    u2			constant_pool_count;</span><br><span class="line">    cp_info		contant_pool[constant_pool_count – <span class="number">1</span>];</span><br><span class="line">    u2			access_flags;</span><br><span class="line">    u2			this_class;</span><br><span class="line">    u2			super_class;</span><br><span class="line">    u2			interfaces_count;</span><br><span class="line">    u2			interfaces[interfaces_count];</span><br><span class="line">    u2			fields_count;</span><br><span class="line">    field_info		fields[fields_count];</span><br><span class="line">    u2			methods_count;</span><br><span class="line">    method_info		methods[methods_count];</span><br><span class="line">    u2			attributes_count;</span><br><span class="line">    attribute_info	attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>magic、minor_version、major_version：指明类的版本和用来编译的JDK的版本</li>
<li>constant_pool: 类似符号表，但包含更多的信息。</li>
<li>access_flag: 提供这个类的修改器列表</li>
<li>this_class:通过提供这个类的完整的index找到常数池，比如：org/jamesdbloom/foo/bar</li>
<li>super_class: 通过提供父类的完整路径的索引指向常数池，比如：java/lang/Object</li>
<li>interface: 通过提供所有指向已经实现的接口的索引。。</li>
<li>fields: 通过提供完整的每个域的描述指向常数池的数组索引</li>
<li>methods: 通过提供每个方法的完整的签名。。。</li>
<li>attributes: 略。</li>
</ul>
<blockquote>
<p>常量池之中主要存放两大变量：字面量（Literal）和符号引用（Symbolic Refences）。字符串比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。符号引用属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</blockquote>
<p>比如编译一下简单的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jvminternals; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么通过下面指令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p -s -sysinfo -constants</span><br><span class="line">classes/org/javinternals/SimpleClass.class</span><br></pre></td></tr></table></figure></p>
<p>将会得到，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class org.jvminternals.SimpleClass   </span><br><span class="line">  SourceFile: "SimpleClass.java"   </span><br><span class="line">  minor version: 0   </span><br><span class="line">  major version: 51   </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER </span><br><span class="line"> Constant pool:    </span><br><span class="line">    #1 = Methodref          #6.#17         //  java/lang/Object."&lt;init&gt;":()V    </span><br><span class="line">    #2 = Fieldref           #18.#19        //  java/lang/System.out:Ljava/io/PrintStream;    </span><br><span class="line">    #3 = String             #20            //  "Hello"    </span><br><span class="line">    #4 = Methodref          #21.#22        //  java/io/PrintStream.println:(Ljava/lang/String;)V    </span><br><span class="line">    #5 = Class              #23            //  org/jvminternals/SimpleClass    </span><br><span class="line">    #6 = Class              #24            //  java/lang/Object    </span><br><span class="line">    #7 = Utf8               &lt;init&gt;    </span><br><span class="line">    #8 = Utf8               ()V    </span><br><span class="line">    #9 = Utf8               Code   </span><br><span class="line">    #10 = Utf8               LineNumberTable   </span><br><span class="line">    #11 = Utf8               LocalVariableTable   </span><br><span class="line">    #12 = Utf8               this   </span><br><span class="line">    #13 = Utf8               Lorg/jvminternals/SimpleClass;   </span><br><span class="line">    #14 = Utf8               sayHello   </span><br><span class="line">    #15 = Utf8               SourceFile   </span><br><span class="line">    #16 = Utf8               SimpleClass.java   </span><br><span class="line">    #17 = NameAndType        #7:#8          //  "&lt;init&gt;":()V   </span><br><span class="line">    #18 = Class              #25            //  java/lang/System   </span><br><span class="line">    #19 = NameAndType        #26:#27        //  out:Ljava/io/PrintStream;   </span><br><span class="line">    #20 = Utf8               Hello   </span><br><span class="line">    #21 = Class              #28            //  java/io/PrintStream   </span><br><span class="line">    #22 = NameAndType        #29:#30        //  println:(Ljava/lang/String;)V   </span><br><span class="line">    #23 = Utf8               org/jvminternals/SimpleClass   </span><br><span class="line">    #24 = Utf8               java/lang/Object   </span><br><span class="line">    #25 = Utf8               java/lang/System   </span><br><span class="line">    #26 = Utf8               out   </span><br><span class="line">    #27 = Utf8               Ljava/io/PrintStream;   </span><br><span class="line">    #28 = Utf8               java/io/PrintStream   </span><br><span class="line">    #29 = Utf8               println   </span><br><span class="line">    #30 = Utf8               (Ljava/lang/String;)V </span><br><span class="line"> &#123;   </span><br><span class="line">    public org.jvminternals.SimpleClass();     </span><br><span class="line">    Signature: ()V     </span><br><span class="line">    flags: ACC_PUBLIC     </span><br><span class="line">    Code:       </span><br><span class="line">      stack=1, locals=1, args_size=1         </span><br><span class="line">        0: aload_0         </span><br><span class="line">        1: invokespecial #1    // Method java/lang/Object."&lt;init&gt;":()V         </span><br><span class="line">        4: return       </span><br><span class="line">      LineNumberTable:         </span><br><span class="line">        line 3: 0       </span><br><span class="line">      LocalVariableTable:         </span><br><span class="line">        Start  Length  Slot  Name   Signature          </span><br><span class="line">         0      5      0    this   Lorg/jvminternals/SimpleClass;    </span><br><span class="line">    public void sayHello();     </span><br><span class="line">    Signature: ()V     </span><br><span class="line">    flags: ACC_PUBLIC     </span><br><span class="line">    Code:       </span><br><span class="line">      stack=2, locals=1, args_size=1         </span><br><span class="line">        0: getstatic      #2    // Field java/lang/System.out:Ljava/io/PrintStream;         </span><br><span class="line">        3: ldc            #3    // String "Hello"         </span><br><span class="line">        5: invokevirtual  #4    // Method java/io/PrintStream.println:(Ljava/lang/String;)V         </span><br><span class="line">        8: return       </span><br><span class="line">      LineNumberTable:        </span><br><span class="line">        line 6: 0         </span><br><span class="line">        line 7: 8       </span><br><span class="line">      LocalVariableTable:        </span><br><span class="line">        Start  Length  Slot  Name   Signature          </span><br><span class="line">         0      9      0    this   Lorg/jvminternals/SimpleClass; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="各个组件的细节">各个组件的细节</h2><h3 id="运行时常量池">运行时常量池</h3><p>Java的bytecode需要数据，但是常常这些数据都太大以至于不能直接存储在bytecode中，所以它存储在常量池中并且bytecode保存着指向常量池的引用。运行时常量池使用的是动态链接。</p>
<p>一些存储在常量池中的数据有如下类型：</p>
<ol>
<li>numeric literaal:数值常量</li>
<li>String literals:字面串常量String a = “123”</li>
<li>Class references：类引用</li>
<li>Field reference：字段引用</li>
<li>Method reference：方法引用</li>
</ol>
<p>比如说：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object foo = <span class="keyword">new</span> Object()</span><br></pre></td></tr></table></figure></p>
<p>它的bytecode代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: 	new #2 		    // Class java/lang/Object  </span><br><span class="line">1:	dup  </span><br><span class="line">2:	invokespecial #3    // Method java/ lang/Object "&lt;init&gt;"( ) V</span><br></pre></td></tr></table></figure></p>
<p>new指令后接#2,这个操作数是一个指向常量池的引用，索引值为2，第二个索引是一个类引用，这个所以接着指向常量池中另外一个索引： UTF8 Class java/lang/Object。这个符号连接可以被用来找到java.lang.Object的类。new操作符创造了一个类实例并且初始化它的变量。一个指向类实例的引用然后被加入到operand stack中。Dup指令然后复制了operand stack栈顶的引用并再次加入到栈顶。最后，一个实例初始化方法被调用invokespecial。这个指令同样包含了一个指向常量池的引用。操作符将栈顶的引用当着参数消耗掉。在最后只用一个指向新对象的引用存在。</p>
<p>如果编译一下的简单代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jvminternals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>常量池将会如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#17         //  java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #18.#19        //  java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #20            //  "Hello"</span><br><span class="line">   #4 = Methodref          #21.#22        //  java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #23            //  org/jvminternals/SimpleClass</span><br><span class="line">   #6 = Class              #24            //  java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lorg/jvminternals/SimpleClass;</span><br><span class="line">  #14 = Utf8               sayHello</span><br><span class="line">  #15 = Utf8               SourceFile</span><br><span class="line">  #16 = Utf8               SimpleClass.java</span><br><span class="line">  #17 = NameAndType        #7:#8          //  "&lt;init&gt;":()V</span><br><span class="line">  #18 = Class              #25            //  java/lang/System</span><br><span class="line">  #19 = NameAndType        #26:#27        //  out:Ljava/io/PrintStream;</span><br><span class="line">  #20 = Utf8               Hello</span><br><span class="line">  #21 = Class              #28            //  java/io/PrintStream</span><br><span class="line">  #22 = NameAndType        #29:#30        //  println:(Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               org/jvminternals/SimpleClass</span><br><span class="line">  #24 = Utf8               java/lang/Object</span><br><span class="line">  #25 = Utf8               java/lang/System</span><br><span class="line">  #26 = Utf8               out</span><br><span class="line">  #27 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #28 = Utf8               java/io/PrintStream</span><br><span class="line">  #29 = Utf8               println</span><br><span class="line">  #30 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure></p>
<p>常量池主要包括一下类型：</p>
<ul>
<li>Interger: 一个4字节的常量</li>
<li>Long:     一个8字节的常量</li>
<li>Float:    一个4字节的浮点数常量</li>
<li>Double:   一个8字节的浮点数常量</li>
<li>String:   一个字符串常量指向一个UTF8的入口(他包含真正的字符串常量)。</li>
<li>UTF8:     一个以UTF8编码的字节流。</li>
<li>Class:    一个指向另外一个UTF8入口的类常量(此入口包含真正的类名)</li>
<li>NameAndType:一个以“.”分割的值，每一个指向常量池的另一个入口。第一个值指向一个UTF8入口(它是一个方法或者域名称)，第二个指向另一个UTF8入口(它表示类型)。如果第一个是域名称，第二个则是一个完整的类名。如果第一个是方法名，第二个这是参数列表。</li>
<li>Fieldref,Methodref,InterfaceMethodref: 一个以“.”分割的值，每一个值指向常量池的另一个入口。第一个入口指向一个类入口，第二个指向一个NameAndType入口。</li>
</ul>
<h3 id="属性(方法)表集合">属性(方法)表集合</h3><p><img src="/images/JVM/JVM8.jpg" alt="虚拟机规范预定义的属性"></p>
<p>现在我们来方法表中的异常属性。<br>异常表存储了每个异常句柄的信息，像：</p>
<ol>
<li>起位置</li>
<li>终位置</li>
<li>PC偏移量</li>
<li>正捕捉异常的常量池索引<br>如果一个方法定义了一个try-catch或者try-final的异常句柄，那么一个异常表就会被创建。这包括了每个异常句柄的信息或者final块信息。<br>当一个异常被抛出时，JVM就会在当前方法中搜素匹配的句柄；如果没有找到匹配的，方法将会终止、从当前栈中弹出并且异常在新的当前框架中被重新抛出。如果在所有框架没有完全弹出栈之前没有找到匹配的异常句柄，这个线程就会被终止。如果这个线程是最后的非守护线程，那么JVM将会自终止，例如这个线程是主线程。<br><img src="/images/JVM/JVM9.PNG" alt="异常属性"></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-deep-into-JVM-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/02/deep-into-JVM-3/" class="article-date">
  	<time datetime="2015-08-02T10:56:18.000Z" itemprop="datePublished">2015-08-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/02/deep-into-JVM-3/">深入理解JVM(3)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是我写的关于《深入理解Java虚拟机：JVM高级特性与最佳实战（第2版）》的读书笔记。</p>
<h1 id="HotSpot虚拟机架构">HotSpot虚拟机架构</h1><p>以下这幅图展示了Java虚拟机里面的关键组件(是依据Java SE 7版本的Java虚拟机)。<br><img src="/images/JVM/JVM4.png" alt="HotSpot虚拟机"></p>
<h1 id="虚拟机栈">虚拟机栈</h1><p>每当一个方法被调用时，一个新的Frame被创建并且push到虚拟机栈中。<br>每个Frame包括如下：</p>
<ol>
<li>局部变量表</li>
<li>返回值</li>
<li>操作栈(Operand Stack)</li>
<li>指向当前方法的类的运行时常量池的引用<h2 id="局部变量表">局部变量表</h2>局部变量表包括方法执行期间的变量：包括一个this引用，所有的方法参数和其他局部定义变量。对于类方法(比如.静态方法)，方法参数从零开始；然而对于实例方法，零槽位保留给this。<br>一个局部变量可以是：</li>
</ol>
<ul>
<li>boolean</li>
<li>byte</li>
<li>char</li>
<li>long</li>
<li>short</li>
<li>int </li>
<li>float</li>
<li>double</li>
<li>reference</li>
<li>returnAddress</li>
</ul>
<h2 id="操作栈">操作栈</h2><p>有点类似CPU中一般目的的寄存器，the operand stack在执行byte code指令时使用。大多数JVM byte code 将时间花费在操纵operand stack上：比如push,pop,duplicate,swap,或者执行产生或者消费变量的操作上。因此，在byte code中，那些在局部变量数组和operand stack之间的移动数据是非常频繁的。例如，一个简单的变量初始化会产生两个与operand stack打交道的byte codes。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure></p>
<p>会得到编译后的byte code:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iconst_0 <span class="comment">//push 0 to top of the operand stack</span></span><br><span class="line">istore_1 <span class="comment">//pop value from top of operand stack and store as local variable 1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="动态链接">动态链接</h2><p>每个Frame都包含一个指向当前方法的类的运行时常量池的引用。这个引用是用来支持动态链接的。</p>
<p>当一个Java类被编译时，所有的指向变量和方法的引用被作为一个符号引用保存在该类常量池中。符号引用是一个逻辑引用而不是一个指向实际地址的引用。JVM实现版本可是选择何时解决这些标记引用，这过程可以放生在类文件被识别时、加载之后，这叫做贪心或者静态解析；或者发生在当此标记引用被使用时，这叫做懒惰或者后期解析。绑定是以标记引用标识的区域(field)、方法、或者类被直接引用代替的过程。所有的直接引用都会以运行位置相关的存储结构偏移量类存储的。</p>
<h1 id="垃圾回收">垃圾回收</h1><h2 id="根搜索算法">根搜索算法</h2><p>在主流的商用程序语言中，都是使用根搜索算法(GC Roots Tracing)判定对象是否存活的。<br>在Java语言中，可作为GC Roots的对象包括以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法栈中<a href="http://www.cnblogs.com/mandroid/archive/2011/06/15/2081093.html" target="_blank" rel="external">JNI</a>(即一般说的Native方法)的引用的对象</li>
</ul>
<h2 id="回收永久代">回收永久代</h2><p>很多人认为JVM中的永久代是没有垃圾收集的，Java虚拟机规范的确说明可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾手机的‘性价比’是比较低的；在堆中，尤其是新生代中，常规应用进行依次垃圾收集一般可以回收70%~90%的空间，而在永久代中的垃圾收集效率远低于此。<br>永久代回收主要回收两部分内容：</p>
<ol>
<li>废弃变量；包括字面量（String）,常量池中的其他类(接口)、方法、字段的符号引用等。</li>
<li>无用的类；无用类需要满足下面三个条件<ul>
<li>该类的所有实例均已经回收，即Java堆中不存在该类的任何实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ol>
<h2 id="垃圾收集算法">垃圾收集算法</h2><h3 id="标记-清除算法">标记-清除算法</h3><p>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有标记的对象。<br>缺点：</p>
<ol>
<li>效率不高；标记和清除的效率都不高；</li>
<li>空间问题；标记清楚后会产生大量不连续的内存碎片；</li>
</ol>
<h3 id="复制算法">复制算法</h3><p>将内存容量分为大小相等的两块，每次只是只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br><strong> 现在的商用虚拟机都采用这种收集算法来回收新生代，如HotSpot虚拟机将新生代分为Eden空间和两块较小的Survivor空间， 每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性的拷贝到另外一块Survivor空间中，最后清理掉Eden和刚才用过的Survivor空间。 </strong></p>
<h2 id="标记-整理算法">标记-整理算法</h2><p>根据老年代的特点，有人提出了一种“标记-整理(Mark-Compact)算法”,过程依然与“标记-清除算法”一样，不过后续步骤是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存，以便清除内存碎片。</p>
<h2 id="垃圾收集器">垃圾收集器</h2><p>垃圾收集器是垃圾回收算法的具体实现；<br>下图描述了HotSpot收集器的示意图：<br><img src="/images/JVM/JVM7.jpg" alt="HotSpot收集器"></p>
<h3 id="Serial收集器">Serial收集器</h3><p>单线程；在它收集时，必须暂停其他的工作线程，直至它收集结束。<br>特点：简单高效；对于运行在Client模式下的虚拟机来说是一个好选择。</p>
<h3 id="PawNew收集器">PawNew收集器</h3><p>是Serial收集器的多线程版本。</p>
<blockquote>
<p>在讨论垃圾收集器的上下文语境中：</p>
<ul>
<li>并行： 指多条垃圾收集器线程并行工作，但此时用户线程依然处于等待状态</li>
<li>并发： 指用户线程与垃圾收集线程同时运行（但不一定是并行的，可能会交替运行），用户程序继续运行，而垃圾收集程序运行在另一个CPU上。</li>
</ul>
</blockquote>
<h3 id="Parallel_Scavenge收集器">Parallel Scavenge收集器</h3><p>新生代收集器，使用“复制”算法，并行的多线程收集器。着重于达到一个可控制的吞吐量。</p>
<blockquote>
<p>吞吐量 = 运行用户代码时间/(运行用户带啊时间+垃圾收集时间)</p>
</blockquote>
<h3 id="Serial_Old收集器">Serial Old收集器</h3><p>是Serial收集器的老年代版本，单线程收集器，使用“标记-整理”算法。</p>
<h3 id="Parallel_Old收集器">Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年代版本。</p>
<h3 id="CMS收集器">CMS收集器</h3><p>系统停顿很短。</p>
<h3 id="G1收集器">G1收集器</h3><ul>
<li>使用“标记-整理”算法实现。</li>
<li>可精确的控制停顿。</li>
</ul>
<h2 id="内存分配和回收策略">内存分配和回收策略</h2><h3 id="对象优先在Eden分配">对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发动一MinorGC。</p>
<h3 id="大对象直接进入老年代">大对象直接进入老年代</h3><p>很长的字符串及数组会直接分配到老年代。</p>
<h3 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</h3><p>通过对对象定义年龄的概念，当对象年龄增加到一定程度(默认为15岁)，就会被晋升到老年代。</p>
<h3 id="空间分配担保">空间分配担保</h3><p>当出现MinorGC后依然存活大量的对象是，就需要老年代进行担保，让Survior无法容纳的对象直接进入老年代。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-deep-into-JVM-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/02/deep-into-JVM-2/" class="article-date">
  	<time datetime="2015-08-02T08:16:11.000Z" itemprop="datePublished">2015-08-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/02/deep-into-JVM-2/">深入理解JVM(2)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是我写的关于《深入理解Java虚拟机：JVM高级特性与最佳实战（第2版）》的读书笔记。</p>
<h2 id="HotSpot虚拟机架构">HotSpot虚拟机架构</h2><p>以下这幅图展示了Java虚拟机里面的关键组件(是依据Java SE 7版本的Java虚拟机)。<br><img src="/images/JVM/JVM4.png" alt="HotSpot虚拟机"></p>
<h2 id="线程">线程</h2><p>一个线程是程序的一次执行。JVM允许一个应用程序并行运行多个线程。在Hotspot JVM中存在着在Java线程和本地操作系统线程之间的映射。在准备完一个Java线程的所有状态，像thread-local存储、缓冲分配、对象同步、栈和程序计数器之后，本地线程就被创造出来了。本地线程将在Java线程终止后被回收。操作系统因此负责调度所有的线程和分配给它们可用的CPU。一旦本地线程初始化后，它将调用Java 线程里面的run()方法。当run()方法返回时，未捕捉的异常被处理，随后本地线程确定JVM是否需要因为线程的终止而被终止(比如说，它是最后的非守护线程)。当线程终止后，所有本地线程的和JVM线程的资源将被释放。</p>
<h3 id="JVM系统线程">JVM系统线程</h3><p>如果你是用jconsole或者其他任何调试器是有可能看到后台有无数的线程在运行。这些后台线程运行是来补充主线程的，其部分是由于调用public static void main(String[])而构造出来的。在Hotspot JVM系统中主要的后台系统线程如下：</p>
<ul>
<li>VM 线程：这个线程等待那些需要JVM到达一个安全点(Safe-point)的操作。之所以这些操作需要发生在一个独立的线程是因为它们都需要JVM在一个安全点(safe-point)、这个点对堆的修改不会出现。线程执行的操作是stop-the-world型的垃圾回收器、线程栈dumps、thread suspension、和biased locking revocation。</li>
<li>Periodic task 线程:这些线程是负责哪些用于调度阶段性的操作执行的时间事件(比如中断)</li>
<li>GC 线程： 这些线程支持不同类型的垃圾回收活动</li>
<li>Compiler 线程： 这些线程在运行时将byte code编译成本地码</li>
<li>Signal dispatcher thread 这个线程接受发送给JVM进程的信号并且通过调用合适的JVM方法处理它们。<h3 id="每个线程">每个线程</h3>每一个线程有如下组件：<ol>
<li>程序计数器(PC):除非它是本地的(Native)(在这种情况，PC的值为空(Undefined))，那么PC表示当前指令的地址，JVM用PC去追踪当前执行的指令；事实上PC将会指向方法区(Method Area)的一个内存地址；每条线程都需要一个独立的PC，各条线程之间互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</li>
<li>栈：虚拟机栈描绘的是Java方法执行的内存模型：每个方法被执行的时候同时会创建一个栈帧(Stack Frame)用于存储局部变量表、操作栈、动态连接、方法出口(Return)等信息。在Java虚拟机规范中，对这个区域规定了两种异常情况：StackOverflowError异常；OutOfMemoryError异常（虚拟机栈在扩展时无法申请到足够的内存时会抛出）。</li>
<li>本地方法栈(Native Stack)：本地方法栈与虚拟机栈所发挥的作用是非常相似的其区别不过是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机执行Native方法服务。同样，在Java虚拟机规范中，对这个区域规定了两种异常情况：StackOverflowError异常；OutOfMemoryError异常（虚拟机栈在扩展时无法申请到足够的内存时会抛出）。</li>
<li>栈限制：一个栈可以是动态的或者固定的大小。如果一个线程需要一个大的栈那么一个StackOverflowError异常被抛出。如果一个线程需要一些多的框架并且没有足够的存储分配那么一个OutOfMemoryError异常被抛出。</li>
</ol>
</li>
</ul>
<p><strong> 关于每个虚拟机栈的具体内容，可见会在下几个章节总结出来 </strong></p>
<h2 id="线程共享的内容">线程共享的内容</h2><h3 id="堆内存">堆内存</h3><p>堆是用于在运行时分配类实例和数组的。因为一个框架(Frame)在创建后不是被设计为可以改变的，所以数组和对象永远不会存储在栈中。框架只会存储指向堆中的对象或者数组的引用。不像原始变量和引用存储在局部变量数组(在框架)中，对象总是存储在堆中，所以它们在一个方法结束后不会被移除。相反对象只会被垃圾收集器移除。</p>
<h3 id="非堆内存">非堆内存</h3><p>那些被逻辑上认为是JVM机制的一部分对象不是被创建在堆中。<br>非堆内存包括：</p>
<ol>
<li>永久一代(permanent generation), 包括：<ul>
<li>方法区(method area)</li>
<li>内部字符串</li>
</ul>
</li>
<li>缓存代码：主要用来存储那些被JIT编译器编译成的本地码(Native Code)</li>
</ol>
<blockquote>
<p>Just In Time(JIT) Compilation：Java byte code 是被解释的但是这个并没有直接在JVM的宿主机CPU上执行本地代码快。为了改善性能，Oracle Hotspot VM寻找那些频繁执行的byte code代码并将它们编译成本地码。本地代码然后存放在缓存代码中(code cache)。用这种方法，Hotspot VM试着选择最合适的方法去在编译代码和执行解释的代码之间取得平衡。</p>
</blockquote>
<p><strong> 关于方法区的具体内容会在下几个章节写</strong></p>
<h2 id="对象访问">对象访问</h2><p>对象访问涉及到Java栈、Java堆、方法去这三个重要的内存区域。<br>例如下面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></p>
<p>假设这句代码出现在方法体中，那么“Object obj”这部分语意将反映在Java栈的本地变量表中，作为一个reference类型出现。而“new Object()”这部分的语义将会反映在Java堆中，形成一块存储了Ojbect()类型所有实例数据值(Instance Data, 对象中各个实例字段的数据)的结构化内存。另外在Java堆中还必须包含能查找到此对象类型数据(如对象类型、父类、实现的接口、方法等)的地址信息，这些类型信息则存储在方法区中。<br>由于reference类型在Java虚拟机规范里只定义了一个指向对象的引用，并没有定义这个引用应该通过那种方式去定位，以及访问到Java堆中的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的有两种：使用句柄和直接指针。</p>
<ul>
<li>通过句柄访问对象：<br><img src="/images/JVM/JVM5.PNG" alt="通过句柄访问对象"></li>
<li>通过直接指针访问方式：<br><img src="/images/JVM/JVM6.PNG" alt="通过直接指针访问方式"></li>
</ul>
<p><strong> 引用 </strong></p>
<ol>
<li><a href="http://www.cnblogs.com/maverick-fu/p/4451811.html#3170784" target="_blank" rel="external">JVM剖析</a></li>
<li><a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="external">JVM Internals</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-deep-into-JVM-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/31/deep-into-JVM-1/" class="article-date">
  	<time datetime="2015-07-31T13:07:34.000Z" itemprop="datePublished">2015-07-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/31/deep-into-JVM-1/">深入理解JVM(1)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是我写的关于《深入理解Java虚拟机：JVM高级特性与最佳实战（第2版）》的读书笔记。</p>
<h2 id="Java技术体系">Java技术体系</h2><p><img src="/images/JVM/JVM1.jpg" alt="Java技术体系"><br>其中</p>
<blockquote>
<p>JDK = Java程序设计语言 + Java虚拟机 + Java API类库<br>JRE = Java虚拟机 + Java SE API子集</p>
</blockquote>
<h2 id="Sun_HotSpot_JVM">Sun HotSpot JVM</h2><blockquote>
<p>Shortly after acquiring Animorphic, Sun intended to write a new just-in-time (JIT) compiler for the newly developed virtual machine.[3] This new compiler would give rise to the name “HotSpot”, which derives from the fact that, as the software runs Java bytecode, it continually analyzes the program’s performance for “hot spots” which are frequently or repeatedly executed. These are then targeted for optimization, leading to high-performance execution with a minimum of overhead for less performance-critical code. –<a href="https://en.wikipedia.org/wiki/HotSpot" target="_blank" rel="external">Wikipedia</a></p>
</blockquote>
<p>Sun公司主要开发两种JVM: 客户端虚拟机和服务器端虚拟机；客户端虚拟机主要为应用程序快速加载而调制；服务器端版本加载更慢，但运行更加高效。</p>
<p>HotSpot提供如下部件：</p>
<ul>
<li>一个<a href="https://en.wikipedia.org/wiki/Java_Classloader" target="_blank" rel="external">类加载器</a></li>
<li>一个<a href="https://en.wikipedia.org/wiki/Java_bytecode" target="_blank" rel="external">字节码</a><a href="https://en.wikipedia.org/wiki/Interpreter_(computing" target="_blank" rel="external">解释器</a>)</li>
<li>客户端和服务器端虚拟机</li>
<li>一些<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science" target="_blank" rel="external">垃圾收集器</a>)</li>
<li>运行库集合</li>
</ul>
<p>HotSpot源码结构图:<br><img src="/images/JVM/JVM2.PNG" alt="HotSpot源码结构"><br><img src="/images/JVM/JVM3.PNG" alt="HotSpot源码结构"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Fu Xi
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>